#---------------------------------------------------------------------
# Script Name:   RFunctionsSupportingTASSELPlugin.R
# Description:   Various tests with rJava
# Author:        Brandon Monier & Ed buckler
# Created:       2018-11-26 at 11:14:36
# Last Modified: 2019-02-07 at 00:09:04
#--------------------------------------------------------------------

#--------------------------------------------------------------------
# Detailed Purpose:
#    The main purpose of this Rscript to support the autogenerated wrappers
#   for TASSEL plugins in TasselPluginWrappers
#--------------------------------------------------------------------

#' @title Converts a formula into a GWAS model design that can be used by
#'    TASSEL PhenotypeGenotype
#'
#' @details . is used for all variable, + to add one, - to exclude, list() used for multiple responses
#'
#' @param phenotypeGenotype TASSEL PhenotypeGenotype Object
#' @param fixed An R formula (lm) notation for fixed effects
#' @param kinship A TASSEL kinship matrix
#'
#' @return tibble dataframe defining data, covariates, factors, taxa, and genotypes to be used
#'
#' @importFrom tibble add_case
#' @importFrom magrittr %>%
#' @importFrom dplyr mutate
#' @importFrom dplyr filter
#' @importFrom dplyr pull
#' @importFrom purrr pmap_chr
#' @export
#'
#'
# @examples
# phenotypeGenotype <- genoPhenoCombined1
# assocFormula <- . ~ dpoll
# assocFormula <- list(EarHT,EarDia) ~ dpoll
# assocFormula <- list(EarHT,EarDia) ~ dpoll + Taxa
# assocFormula <- list(.) ~ dpoll
# assocFormula <- list(EarHT,EarDia) ~ .
# assocFormula <- list(dpoll,EarHT) ~ .
# assocFormula <- list(.) ~ . # poorly defined what is on what side - throw error

# TODO Add conditionals for incorrect formula entries (Brandon)
# TODO Add stop or warning for `list(.) ~ .` formulas (Brandon)
# TODO Support proper kinship data import `kinshipPlugin` from TASSEL (Ed)
# TODO Create class for kinship/distance matrices? (Ed and Brandon)
# TODO conduct BLUE/GLM/MLM based on design structure in TASSEL (Ed)

# currently supports the symbol "G" for genotype parameter in formula - may change...
assocModelDesign <- function(phenotypeGenotype,
                             fixed,
                             kinship = NULL) {
    #Digest a formula to set the phenotypes to one of these ATTRIBUTE_TYPE
    #enum ATTRIBUTE_TYPE {data, covariate, factor, taxa};
    #Use G for GenotypeTable present,
    #Taxa can be used for BLUEs, e.g. dpoll ~ Taxa

    ## Get intial association metadata
    ## Add Genotype (G) row for final conditional steps
    jtsPheno <- getPhenotypeTable(phenotypeGenotype)
    phenoAttDf <- extractPhenotypeAttDf(jtsPheno)
    phenoAttDf <- tibble::add_case(
        phenoAttDf,
        traitName = "G",
        traitType = "genotype",
        traitAttribute = "Genotype"
    )
    df <- emptyDFWithPhenotype(phenoAttDf)

    ## Identify fixed terms from formula
    term_fixed <- terms(as.formula(fixed), data = df)

    ## Define if element in df is fixed, random, or not used
    vFixed <- ifelse(
        test = names(df) %in% attr(term_fixed, "term.labels"),
        yes = "fixed",
        no = ""
    )
    vNull <- ifelse(
        test = !(names(df) %in% c(
            attr(term_fixed, "term.labels"))
        ),
        yes = NA,
        no = ""
    )
    effect <- with(list(vFixed, vNull), paste0(vFixed, vNull))

    # TODO - Fix `list(.)` with new fixed and random effects parameters (Brandon)
    # replace list(.) with the unused numeric attributes
    # if (any(grepl(pattern = "list\\(\\.\\)", fixed))) {
    #     labelsUsed <- terms(as.formula(fixed), data = df) %>%
    #         attr("term.labels")
    #     unusedNumericNames <- phenoAttDf %>%
    #         dplyr::filter(traitAttribute == "NumericAttribute") %>%
    #         dplyr::filter(!traitName %in% labelsUsed) %>%
    #         dplyr::pull(traitName)
    #     listDotReplacementStr <- paste0(
    #         "list(",
    #         paste(unusedNumericNames, collapse = ", "),
    #         ")"
    #     )
    #     fixed <- gsub(
    #         pattern = "list\\(\\.\\)",
    #         replacement = listDotReplacementStr,
    #         x = deparse(fixed)
    #     ) %>% formula()
    # }

    if (attr(term_fixed, "response") == 0) {
        stop(
            paste(
                "Define a response variable (a trait name in the phenotypes),",
                "e.g. list(trait1, trait2) or list(.) for all traits"
            )
        )
    }

    ## Add three new columns to describe new model
    ## AKA the "choose your own adventure" object for conditional statements
    newPhenoAttDf <- dplyr::mutate(
        phenoAttDf,
        isReponse = traitName %in% as.character(fixed[[2]]),
        isPredictor = traitName %in% c(
            attr(term_fixed, "term.labels")
        ),
        newType = purrr::pmap_chr(
            list(traitAttribute, isReponse, isPredictor),
            rTASSEL:::tasselTypeMap
        ),
        effect = effect
    )
    newPhenoAttDf[newPhenoAttDf == "NA"] <- NA

    ## Logic flow parameters
    taxaStat <- newPhenoAttDf[newPhenoAttDf$traitType == "taxa", "effect"]
    gStat    <- newPhenoAttDf[newPhenoAttDf$traitType == "genotype", "effect"]
    kinStat  <- kinship

    randCheck <- NULL

    ## Initial check for taxa random effect
    if (is.na(taxaStat) & !is.null(kinship)) {
        newPhenoAttDf[newPhenoAttDf$traitType == "taxa", "effect"] <- "random"
        randCheck <- "~ taxa"
    } else if (taxaStat == "fixed" & !is.null(kinship)) {
        warning("Converting taxa from \"fixed\" to \"random\"...")
        newPhenoAttDf[newPhenoAttDf$traitType == "taxa", "effect"] <- "random"
        randCheck <- "~ taxa"
    } else if (is.na(gStat) & !is.null(kinStat)) {
        stop("Missing genotype from MLM formula")
    }

    ## Console formula checks
    message("Fixed effect    : ", deparse(fixed))
    message(
        "Random effect   : ",
        ifelse(
            test = is.null(randCheck),
            yes = "none",
            no = randCheck
        )
    )

    ## Update taxa status
    taxaStat <- newPhenoAttDf[newPhenoAttDf$traitType == "taxa", "effect"]

    ## Logic flow...
    if (taxaStat == "fixed" & is.na(gStat)) {
        message("Perform BLUE analysis...")
    } else if (is.na(taxaStat) & gStat == "fixed") {
        message("Perform GLM analysis...")
    } else if (gStat == "fixed" & taxaStat == "random" & !is.null(kinStat)) {
        message("Perform MLM analysis...")
    } else {
        message("I don't know what you want...")
    }

    ## Return association data frame for TASSEL analysis
    return(newPhenoAttDf)
}



tasselTypeMap <- function(traitAttribute, isResponse, isPredictor) {
    if(isResponse) {
        ifelse(traitAttribute == "NumericAttribute", return("data"), return(NA))
    } else if(isPredictor == FALSE) {
        return(NA)
    } else {
        return(
            switch(
                EXPR = as.character(traitAttribute),
                "TaxaAttribute" = "taxa",
                "NumericAttribute" = "covariate",
                "CategoricalAttribute" = "factor",
                "Genotype" = "genotype"
            )
        )
    }
}



#' @title Method for wrapping TASSEL objects in Datum and Dataset
#' @param tasObj a vector of TASSEL objects
#' @return a TASSEL Dataset
#' @export
createTasselDataSet <- function(tasObj) {
    arguments <- as.list(tasObj)
    jList <- new(J("java/util/ArrayList"))
    for(javaObj in arguments) {
        # check if they are all TASSEL jobj
        if(is(javaObj, "jobjRef") == FALSE) {
            stop("Object ", javaObj, " is not of class")
        }
        jList$add(
            new(J("net/maizegenetics/plugindef/Datum"), "FromR", javaObj, NULL)
        )
    }
    new(J("net/maizegenetics/plugindef/DataSet"), jList, NULL)
}


# Converts TASSEL dataset to List of R objects - either DataFrames or TasselGenotypePhenotype S4 Class
.dataSetToListOfRObjects <- function(jtsDataSet) {
    result <- list()
    for(i in 1:(jtsDataSet$getSize())) {
      name <- jtsDataSet$getData(i-1L)$getName()
      if(jtsDataSet$getData(i-1L)$getData() %instanceof% "net.maizegenetics.util.TableReport") {
        result[[name]] <- convertTableReportToDataFrame(jtsDataSet$getData(i-1L)$getData())
      } else {
        tasselRObj <- .tasselObjectConstructor(jtsDataSet$getData(i-1L)$getData())
        if(!is.null(tasselRObj)){
          result[[name]] <- .tasselObjectConstructor(jtsDataSet$getData(i-1L)$getData())
        }
      }
    }
    result
}


## Convert fixed effect LM output to R list
dataSetToListOfDataFrame <- function(jtsDataSet) {
    result <- c()
    for(i in 1:(jtsDataSet$getSize())) {
        name <- jtsDataSet$getData(i-1L)$getName()
        result[[name]] <- convertTableReportToDataFrame(jtsDataSet$getData(i-1L)$getData())
    }
    result
}

## Convert table report to data frame
convertTableReportToDataFrame <- function(tableReport) {
    tableReportVectors <- J("net/maizegenetics/plugindef/GenerateRCode")$tableReportToVectors(tableReport)
    colNum <- length(tableReportVectors$columnNames)
    aDF <- data.frame(tableReportVectors$dataVector$get(0L))
    for(i in 2:(colNum)) {
        aDF[[i]] <- tableReportVectors$dataVector$get(i-1L)
    }
    colnames(aDF) <- tableReportVectors$columnNames
    aDF
}

settingPhenotypeAttr <- function(formula, phenotypeNameVector) {
  #formula <- y ~ x1*x2
  theTerms <- terms(formula)
}
