#---------------------------------------------------------------------
# Script Name:   RFunctionsSupportingTASSELPlugin.R
# Description:   Various tests with rJava
# Author:        Brandon Monier & Ed buckler
# Created:       2018-11-26 at 11:14:36
# Last Modified: 2019-02-07 at 00:09:04
#--------------------------------------------------------------------

#--------------------------------------------------------------------
# Detailed Purpose:
#    The main purpose of this Rscript to support the autogenerated wrappers
#   for TASSEL plugins in TasselPluginWrappers
#--------------------------------------------------------------------

#' @title Converts a formula into a GWAS model design that can be used by
#'    TASSEL PhenotypeGenotype
#'
#' @details . is used for all variable, + to add one, - to exclude, list() used for multiple responses
#'
#' @param phenotypeGenotype TASSEL PhenotypeGenotype Object
#' @param assocFormula Using R formula (lm) notation
#' @param kinship A TASSEL kinship matrix
#'
#' @return tibble dataframe defining data, covariates, factors, taxa, and genotypes to be used
#'
#' @importFrom tibble add_case
#' @importFrom magrittr %>%
#' @importFrom dplyr mutate
#' @importFrom dplyr filter
#' @importFrom dplyr pull
#' @importFrom purrr pmap_chr
#' @export
#'
#'
#' @examples
# phenotypeGenotype <- genoPhenoCombined1
# assocFormula <- . ~ dpoll
# assocFormula <- list(EarHT,EarDia) ~ dpoll
# assocFormula <- list(EarHT,EarDia) ~ dpoll + Taxa
# assocFormula <- list(.) ~ dpoll
# assocFormula <- list(EarHT,EarDia) ~ .
# assocFormula <- list(dpoll,EarHT) ~ .
# assocFormula <- list(.) ~ . # poorly defined what is on what side - throw error

# TODO Add conditionals for incorrect formula entries (Brandon)
# TODO Add stop or warning for `list(.) ~ .` formulas (Brandon)
# TODO Support proper kinship data import `kinshipPlugin` from TASSEL (Ed)
# TODO Create class for kinship/distance matrices? (Ed and Brandon)
# TODO conduct BLUE/GLM/MLM based on design structure in TASSEL (Ed)
assocModelDesign <- function(phenotypeGenotype,
                             fixed,
                             random = NULL,
                             kinship = NULL) {
    #Digest a formula to set the phenotypes to one of these ATTRIBUTE_TYPE
    #enum ATTRIBUTE_TYPE {data, covariate, factor, taxa};
    #Use G for GenotypeTable present,
    #Taxa can be used for BLUEs, e.g. dpoll ~ Taxa

    jtsPheno <- getPhenotypeTable(phenotypeGenotype)
    phenoAttDf <- extractPhenotypeAttDf(jtsPheno)
    # attr(phenoAttDf,"phenotypeGenotype") <- phenotypeGenotype
    phenoAttDf <- tibble::add_case(
        phenoAttDf,
        traitName = "G",
        traitType = "genotype",
        traitAttribute = "Genotype"
    )
    df <- emptyDFWithPhenotype(phenoAttDf)


    term_fixed <- terms(as.formula(fixed), data = df)

    ## Random effects check
    if (is.null(random)) {
        term_random <- ""
    } else {
        term_random <- terms(as.formula(random), data = df)
    }
    if (any(attr(term_fixed, "term.labels") %in% attr(term_random, "term.labels"))) {
        stop("Identical variables identified in fixed and random effects.")
    }


    ## Define if element in df is fixed, random, or not used
    vFixed <- ifelse(
        test = names(df) %in% attr(term_fixed, "term.labels"),
        yes = "fixed",
        no = ""
    )
    vRand <- ifelse(
        test = names(df) %in% attr(term_random, "term.labels"),
        yes = "random",
        no = ""
    )
    vNull <- ifelse(
        test = !(names(df) %in% c(
            attr(term_random, "term.labels"),
            attr(term_fixed, "term.labels"))
        ),
        yes = "NA",
        no = ""
    )
    effect <- with(list(vFixed, vRand, vNull), paste0(vFixed, vRand, vNull))

    # TODO - Fix `list(.)` with new fixed and random effects parameters (Brandon)
    # replace list(.) with the unused numeric attributes
    # if (any(grepl(pattern = "list\\(\\.\\)", fixed))) {
    #     labelsUsed <- terms(as.formula(fixed), data = df) %>%
    #         attr("term.labels")
    #     unusedNumericNames <- phenoAttDf %>%
    #         dplyr::filter(traitAttribute == "NumericAttribute") %>%
    #         dplyr::filter(!traitName %in% labelsUsed) %>%
    #         dplyr::pull(traitName)
    #     listDotReplacementStr <- paste0(
    #         "list(",
    #         paste(unusedNumericNames, collapse = ", "),
    #         ")"
    #     )
    #     fixed <- gsub(
    #         pattern = "list\\(\\.\\)",
    #         replacement = listDotReplacementStr,
    #         x = deparse(fixed)
    #     ) %>% formula()
    # }


    message("Fixed effect:  ", deparse(fixed))
    message("Random effect: ", deparse(random))

    if (attr(term_fixed, "response") == 0) {
        stop(
            paste(
                "Define a response variable (a trait name in the phenotypes),",
                "e.g. list(trait1, trait2) or list(.) for all traits"
            )
        )
    }
    #Add three new columns to describe new model
    newPhenoAttDf <- dplyr::mutate(
        phenoAttDf,
        isReponse = traitName %in% as.character(fixed[[2]]),
        isPredictor = traitName %in% c(
            attr(term_fixed, "term.labels"),
            attr(term_random, "term.labels")
        ),
        newType = purrr::pmap_chr(
            list(traitAttribute, isReponse, isPredictor),
            tasselTypeMap
        ),
        effect = effect
    )

    if (!is.null(kinship)) {
        return(
            list(
                kinshipJavaPointer = "pointerForTASSEL",
                assocModelDF = newPhenoAttDf
            )
        )
    } else {
        return(
            list(
                kinshipJavaPointer = NULL,
                assocModelDF = newPhenoAttDf
            )
        )
    }
}



tasselTypeMap <- function(traitAttribute, isResponse, isPredictor) {
    if(isResponse) {
        ifelse(traitAttribute == "NumericAttribute", return("data"), return(NA))
    } else if(isPredictor == FALSE) {
        return(NA)
    } else {
        return(
            switch(
                EXPR = as.character(traitAttribute),
                "TaxaAttribute" = "taxa",
                "NumericAttribute" = "covariate",
                "CategoricalAttribute" = "factor",
                "Genotype" = "genotype"
            )
        )
    }
}

randOrFixed <- function()


#' @title Method for wrapping TASSEL objects in Datum and Dataset
#' @param ... a collection of TASSEL objects
#' @return a TASSEL Dataset
#' @examples
createTasselDataSet <- function(...) {
  arguments <- list(...)
  jList <- new(J("java/util/ArrayList"))
  for(javaObj in arguments) {
    #check if they are all TASSEL jobj
    if(is(javaObj, "jobjRef") == FALSE) {
      stop(paste0("Object ",javaObj," is not of class"))
    }
    jList$add(new(J("net/maizegenetics/plugindef/Datum"),"FromR",javaObj,NULL))
  }
  new(J("net/maizegenetics/plugindef/DataSet"),jList,NULL)
}


# Converts TASSEL dataset to List of R objects - either DataFrames or TasselGenotypePhenotype S4 Class
.dataSetToListOfRObjects <- function(jtsDataSet) {
  result <- list()
  for(i in 1:(jtsDataSet$getSize())) {
    name <- jtsDataSet$getData(i-1L)$getName()
    if(jtsDataSet$getData(i-1L)$getData() %instanceof% "net.maizegenetics.util.TableReport") {
      result[[name]] <- convertTableReportToDataFrame(jtsDataSet$getData(i-1L)$getData())
    } else {
      tasselRObj <- .tasselObjectConstructor(jtsDataSet$getData(i-1L)$getData())
      if(!is.null(tasselRObj)){
        result[[name]] <- .tasselObjectConstructor(jtsDataSet$getData(i-1L)$getData())
      }
    }
  }
  result
}



settingPhenotypeAttr <- function(formula, phenotypeNameVector) {
  #formula <- y ~ x1*x2
  theTerms <- terms(formula)


}
