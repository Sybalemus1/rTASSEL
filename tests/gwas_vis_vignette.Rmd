---
title: "GWAS_vis_vignette"
author: "Arcadio"
date: "12/13/2018"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Loading up packages
```{r, message=F}
library(rJava)
library(GenomicRanges)
library(SummarizedExperiment)
library(GWASpoly)
library(ggplot2)
library(ggrepel)
library(stringr)
library(rrBLUP)
library(plyr)
```



Set directory, loading up starting functions and rTassel
```{r}
is_experimental <- TRUE

#set workdir for rtassel
setwd("~/myBins/bucklerlabBitbucket/rtassel/")

path_exp_tassel <- paste0(getwd(),"/inst/java/sTASSEL.jar")
path_exp_tassel_libs <- paste0(getwd(),"/inst/java/lib")

## jinit
rJava::.jinit(parameters="-Xmx6g")
.jcall(.jnew("java/lang/Runtime"), "J", "totalMemory")
.jcall(.jnew("java/lang/Runtime"), "J", "maxMemory")

## Add class paths
if(is_experimental == TRUE) {
  tasselPath <- path_exp_tassel
  tasselLibs <- path_exp_tassel_libs
}

rJava::.jaddClassPath(tasselPath)
rJava::.jaddClassPath(tasselLibs)
print(.jclassPath())


## Source files
source("R/AllGenerics.R")
source("R/AllClasses.R")
source("R/TasselPluginWrappers.R")
source("R/PullFunctions.R")
source("R/GWASVisAnnotFuncs.R")
```

Load up genotypes implementing rTassel
```{r}
geno_fileName <- "/Users/jav246/myBins/bucklerlabBitbucket/rtassel/data/mdp_genotype.hmp.txt"

## Make genotype table from tasses sample data
tasGenoTable <- readGenotypeTable(geno_fileName)

## Make summarized experiment from genotypetable
tas_se <- summarizeExperimentFromGenotypeTable(tasGenoTable)

tas_se

genoDF <- GWASpolyGenoFromSummarizedExperiment(tas_se)

dim(genoDF)

genoDF[1:4, 1:8]

#writting data for gwas poly
write.table(genoDF, "~/Downloads/GWASpoly_download/maizeGenotypes_GWASpoly.txt", sep = "\t", col.names = T, row.names = F, quote = F)

```

Load phenotype data
```{r}
###straight load as dataframe, skpping first two rows on tassel specific phenotype table format
pheno_fileName <- "/Users/jav246/myBins/bucklerlabBitbucket/rtassel/data/mdp_phenotype.txt"
phenos <- read.table(file = pheno_fileName, skip = 2, header = T, sep = "\t", na.strings = "NaN")
summary(phenos)

### select sinlge location, as GWASpoly requires single entries for taxa.
phenosOneLoc <- phenos[phenos$location == "A",]
rownames(phenosOneLoc) <- phenosOneLoc$Taxa
###remove location as it is now redundant. 
###Also, GWASpoly expects all traits as initial columns, and fixed effect covariates last
phenosOneLoc <- phenosOneLoc[,-c(2)]

summary(phenosOneLoc)

write.table(phenosOneLoc, "~/Downloads/GWASpoly_download/maizePhenotypes_GWASpoly.txt", sep = "\t", col.names = T, row.names = F, quote = F)
```

Run GWAS
```{r}
## create GWASpoly object with coopted read.GWASpoly function
#uses tassel created summarizedExperiment for genotypes
data_gwasPoly <- se_createGWASpolyObject(ploidy = 2, phenoDF = phenosOneLoc, 
                                         SummarizedExperimentObject =  tas_se, 
                                         format = "numeric", n.traits = 3)

#same as above, but reading written files
data_gwasPoly2 <- read.GWASpoly(ploidy = 2, pheno.file = "~/Downloads/GWASpoly_download/maizePhenotypes_GWASpoly.txt", geno.file = "~/Downloads/GWASpoly_download/maizeGenotypes_GWASpoly.txt", format = "numeric", n.traits = 3, delim = "\t")

all.equal(current = data_gwasPoly, target = data_gwasPoly2)

## add kinship information to object
data_gwasPoly <- set.K(data_gwasPoly)

## set parameters for mixed model
params <- set.params(fixed=unlist(strsplit("Q1,Q2,Q3", ",")),
                     fixed.type=rep("numeric",3))

## run gwas with GWASpoly
data_gwasPoly_res <- GWASpoly(data = data_gwasPoly, models = "additive", 
                              params = params)

#sanity check to ensure markers in object with scores matches markers order in genotype map
if(all(rownames(data_gwasPoly_res@scores$EarDia) == data_gwasPoly_res@map$Marker)){
  message("markers in scores and genotype map match, moving on")
}else{stop("marker names don't match ordering between geno map and scores object")}

```

Create GWASpoly plots and set thresholds to get QTLs
```{r}
qq.plot(data_gwasPoly_res, trait = "EarDia", model = "additive")

#can set Bonferroni|FDR and own pvalue
data_gwasPoly_res <- set.threshold(data_gwasPoly_res, method = "FDR", level=0.05)

#can set any of the 3 traits
manhattan.plot(data_gwasPoly_res, trait = "EarDia", model = "additive")

get.QTL(data = data_gwasPoly_res)

```


Unwrap gwaspoly results class object
```{r}
traitGWASresults <- gwasPolyToDF(data_gwasPoly_res)
traitGWASresults[traitGWASresults$markerLogPVal> traitGWASresults$sigTreshold,]
summary(traitGWASresults)

```

Create simple manhattan like plot for all traits
```{r, fig.height=4, fig.width=7}
manhattan_trait_plot(traitGWASresults = traitGWASresults, traitIDcol = "trait", 
                     positionIDcol = "Position", chromIDcol = "Chrom", pValIDcol = "markerpVal")
```


Parse GFF file to get genes and create GenomicRanges object
```{r}
maizeGFFgenesGR <- gffToGeneGR(gffFile = "~/Box/projectMaize/PHG/cimmyt_assemblies_analy/b73/Zea_mays.AGPv4.40.chr.gff3")
maizeGFFgenesGR
```

Annotating SNPs with their closest gene. Best for annotating purposes.
```{r}
traitGWASresults_annotated <- annotate_gwasRes_byNearest(gwasResDF = traitGWASresults, 
                  annotationGR = maizeGFFgenesGR, positionIDcol_gwas = "Position",  
                  chromIDcol_gwas = "Chrom", outFmt = "data.frame")
summary(traitGWASresults_annotated)
```

Plot manhattan with nearest annotation on significant SNPs or by genomicRange set
Can pass other ggplot functions to modify output visualization
```{r, fig.height=5, fig.width=8}
#plotting by chromosome
manhattan_annot_plot(annotatedGWASresults = traitGWASresults_annotated, 
                     labelType = "annotationName", zoomGR = "none")

#plotting with zoom over each closest significant annotations
manhattan_annot_plot(annotatedGWASresults = traitGWASresults_annotated, 
                     labelType = "composite", zoomGR = "auto", annotateEffect = T, 
                     effectSizeIDcol = "markerEffect_gwas")

#plotting with zoom over genomicRanges
#define genomic ranges of interest
myGRegions <- GRanges(seqnames = c(10, 8, 1), 
                      ranges = IRanges(start=c(144605146-5e5, 44605146-5e5, 1e6), 
                                       end=c(144605146+5e5, 44605146+5e5, 1e7)))
myGRegions

#actual plotting on region still dependent on having any SNPs within the defined range
manhattan_annot_plot(annotatedGWASresults = traitGWASresults_annotated, 
                     labelType = "composite", zoomGR = myGRegions, 
                     annotateEffect = T, effectSizeIDcol = "markerEffect_gwas")

#inclde names of genes in the region
manhattan_annot_plot(annotatedGWASresults = traitGWASresults_annotated, 
                     labelType = "composite", zoomGR = myGRegions, annotateEffect = T, 
                     effectSizeIDcol = "markerEffect_gwas", labelAnnots = T)
```

Get most significant SNP for each annotation/gene
```{r, eval=F, echo=F}
bestHitByAnnot <- data.frame()
for(annotationName in unique(traitGWASresults_annotated$Gene)){
  annotationData <- genesNearestToGWASranges[traitGWASresults_annotated$Gene == annotationName,]
  bestHit <- min(annotationData$markerpVal_gwas)
  bestHitByAnnot <- rbind(bestHitByAnnot, data.frame(Gene = annotationName, bestHitPval = bestHit))  
}

```

Run gwas with rrBLUP
```{r}
markers_rrblup_mat <- apply(genoDF[,-(1:3)],1,convert.snp)

dim(markers_rrblup_mat)

markers_rrblup <- data.frame(genoDF[,c(1:3)], t(markers_rrblup_mat))

colnames(markers_rrblup) <- colnames(genoDF)

dim(markers_rrblup)

markers_rrblup[1:4, 1:8]


k_rrblup <- A.mat(markers_rrblup_mat)

phenosOneLoc_rrblup <- phenosOneLoc[phenosOneLoc$Taxa %in% colnames(markers_rrblup), ]

gwas_rrblup <- GWAS(pheno = phenosOneLoc_rrblup, geno = markers_rrblup, K = k_rrblup, 
                    fixed = unlist(strsplit("Q1,Q2,Q3", ",")), P3D = T, n.core=6, plot = F)

```

